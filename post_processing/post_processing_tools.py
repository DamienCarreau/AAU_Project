"""

Tool functions used to create the alternative dataset

"""
import fileinput
import matplotlib.pyplot as plt
import random, math
import model as md
import numpy as np
import statistics
import json

# data : list of data to smooth
# mean_coeff : number of values to use before and after for the mean
def mean_data(data, mean_coeff):
    values_number = len(data)
    new_data = []
    for i in range(values_number):
        sum = data[i]
        number_values_sum = 1
        for j in range(i+1, i+mean_coeff):
            if j < values_number:
                sum += data[j]
                number_values_sum += 1
        new_data.append(sum/number_values_sum)
    return new_data

# create averaged a and deltarate given a and deltarates for a set of trajectories
def post_process_datas(acceleration_array,deltarate_array,mean_coeff):
    postprocessed_a = []
    postprocessed_d = []
    for i in range(len(acceleration_array)):
        new_acceleration, new_deltarate = post_process_data(acceleration_array[i], deltarate_array[i], mean_coeff)
        postprocessed_a.append(new_acceleration)
        postprocessed_d.append(new_deltarate)
    return postprocessed_a, postprocessed_d

# create averaged a and deltarate given a and deltarate for one trajectory
def post_process_data(acceleration,deltarate,mean_coeff):
    new_acceleration = mean_data(acceleration, mean_coeff)
    new_deltarate = mean_data(deltarate, mean_coeff)
    return new_acceleration, new_deltarate

# create vectors x and y (position of the car)
# x0 : initial state
# acceleration : list of accelerations values
# deltarate : list of deltarates
# DT : time tick
def compute_trajectory(x0, acceleration, deltarate, DT):
    X, Y = [], []
    X.append(x0[0])
    Y.append(x0[1])
    NextState = md.State(x=x0[0], y=x0[1], yaw=x0[2], v=x0[3], d=x0[4])
    for i in range(len(acceleration)):
        NextState = md.update_state(NextState, acceleration[i], deltarate[i]*math.pi/4, DT)
        X.append(NextState.x)
        Y.append(NextState.y)
    return X, Y

# calculate variation rate of a or deltarate (difference before and after averaging)
def variation_rate(data, new_data):
    variation_new_data = 0
    variation_data = 0
    number_of_values = len(new_data)
    for i in range(number_of_values-1):
        # variation += abs(new_data[i]-data[i])
        variation_new_data += abs(new_data[i+1]-new_data[i])
        variation_data += abs(data[i+1]-data[i])
    return abs(variation_data-variation_new_data)/variation_data

# calculate the mean distance between two trajectories
def distance_to_ref(x_ref, y_ref, x, y):
    sum=0
    nb_state = len(x_ref)
    for i in range(nb_state):
        sum += math.sqrt( (x_ref[i] - x[i])**2 + (y_ref[i] - y[i])**2 )
    return sum/nb_state

# calculate variation rates of a and deltarate and distances (between mpc values and smoothed values) for a set of trajectories
def evaluate_datas(x0, a_smooth, a_mpc, d_smooth, d_mpc, DT, nb_trajectory):
    a_rate_array = []
    d_rate_array = []
    distance_array = []
    for i in range(nb_trajectory):
        a_rate, d_rate, distance = evaluate_data(x0[i], a_smooth[i], a_mpc[i], d_smooth[i], d_mpc[i], DT)
        a_rate_array.append(a_rate)
        d_rate_array.append(d_rate)
        distance_array.append(distance)
    return a_rate_array,d_rate_array,distance_array

# calculate variation rates of a and deltarate and distance (between mpc values and smoothed values) for one trajectory
def evaluate_data(x0, a_smooth, a_mpc, d_smooth, d_mpc, DT, display = False):
        X_smooth, Y_smooth = compute_trajectory(x0, a_smooth, d_smooth, DT)
        X_mpc, Y_mpc = compute_trajectory(x0, a_mpc, d_mpc, DT)
        acceleration_variation_rate = variation_rate(a_mpc, a_smooth)
        delta_variation_rate = variation_rate(d_mpc, d_smooth)
        distance_to_mpc_curve = distance_to_ref(X_mpc, Y_mpc, X_smooth,Y_smooth)
        return acceleration_variation_rate, delta_variation_rate, distance_to_mpc_curve

# load a .npy file
def load_npy_file(file_path):
    return np.load(file_path, allow_pickle=True)

# save a .npy file
def save_npy_file(file_path, array):
    np.save(file_path, np.array(array, dtype=object))

# load information files generated by post_processing_generator
def load_array_trajectory_state(file_path):
    array_trajecotry_state = load_npy_file(file_path)
    a_trajectories = []
    d_trajectories = []
    x0_trajectories = []
    for trajectories in array_trajecotry_state:
        tmp_a = []
        tmp_d = []
        for state in trajectories:
            tmp_a.append(state[1][0])
            tmp_d.append(state[1][1])
        a_trajectories.append(tmp_a)
        d_trajectories.append(tmp_d)
    return array_trajecotry_state, a_trajectories, d_trajectories

# build array_state which is an array of states used as inputs by the neural network
def build_array_state(array_trajectory_state, data_to_modify, a_smooth_array, d_smooth_array, distance_mpc, exclusion_value, nb_trajectory):
    array_state = []
    pp_array_state = []
    pp_array_data = []
    nb_excluded = 0
    for i in range(nb_trajectory):
        if distance_mpc[i] > exclusion_value:
            nb_excluded = nb_excluded + 1
        else:
            states = array_trajectory_state[i]
            for j in range(len(states)):
                array_state.append(states[j])
                states[j][1][0] = a_smooth_array[i][j]
                states[j][1][1] = d_smooth_array[i][j]
                pp_array_state.append(states[j])

            # create post processed array data
            pp_array_data.append(data_to_modify[i])
            pp_array_data[i-nb_excluded][4] = len(pp_array_state)  # update data value (index of the states in array state)
    return pp_array_state, array_state, pp_array_data, nb_excluded



